
Door_Security_System.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000a0e  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000048  00800060  00000a0e  00000a82  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .comment      00000030  00000000  00000000  00000aca  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000afc  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 00000128  00000000  00000000  00000b38  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000018ac  00000000  00000000  00000c60  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000a19  00000000  00000000  0000250c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000c63  00000000  00000000  00002f25  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000002d4  00000000  00000000  00003b88  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000645  00000000  00000000  00003e5c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000e7d  00000000  00000000  000044a1  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000d8  00000000  00000000  0000531e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
   8:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
   c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  10:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  14:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  18:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  1c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  20:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  24:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  28:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  2c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  30:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  34:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  38:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  3c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  40:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  44:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  48:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  4c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  50:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	ee e0       	ldi	r30, 0x0E	; 14
  68:	fa e0       	ldi	r31, 0x0A	; 10
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a8 3a       	cpi	r26, 0xA8	; 168
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>
  76:	0e 94 36 01 	call	0x26c	; 0x26c <main>
  7a:	0c 94 05 05 	jmp	0xa0a	; 0xa0a <_exit>

0000007e <__bad_interrupt>:
  7e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000082 <check>:





void check() {
  82:	ff 92       	push	r15
  84:	0f 93       	push	r16
  86:	1f 93       	push	r17
  88:	cf 93       	push	r28
  8a:	df 93       	push	r29
  8c:	cd b7       	in	r28, 0x3d	; 61
  8e:	de b7       	in	r29, 0x3e	; 62
  90:	28 97       	sbiw	r28, 0x08	; 8
  92:	0f b6       	in	r0, 0x3f	; 63
  94:	f8 94       	cli
  96:	de bf       	out	0x3e, r29	; 62
  98:	0f be       	out	0x3f, r0	; 63
  9a:	cd bf       	out	0x3d, r28	; 61
	
	u8 LOC_u8C = 0, Ptrue = 1, key = 0xff;
	u8 password[] = {1, 2, 3, 4}, userinput[4] = {};
  9c:	81 e0       	ldi	r24, 0x01	; 1
  9e:	89 83       	std	Y+1, r24	; 0x01
  a0:	82 e0       	ldi	r24, 0x02	; 2
  a2:	8a 83       	std	Y+2, r24	; 0x02
  a4:	83 e0       	ldi	r24, 0x03	; 3
  a6:	8b 83       	std	Y+3, r24	; 0x03
  a8:	84 e0       	ldi	r24, 0x04	; 4
  aa:	8c 83       	std	Y+4, r24	; 0x04
  ac:	1d 82       	std	Y+5, r1	; 0x05
  ae:	1e 82       	std	Y+6, r1	; 0x06
  b0:	1f 82       	std	Y+7, r1	; 0x07
  b2:	18 86       	std	Y+8, r1	; 0x08
	u8 passwordsize = sizeof(password) / sizeof(password[0]);
	u8 attemptCount = 0; // Counter for wrong attempts
	
	LED_voidON(DIO_PORTC,led0);
  b4:	62 e0       	ldi	r22, 0x02	; 2
  b6:	82 e0       	ldi	r24, 0x02	; 2
  b8:	0e 94 65 03 	call	0x6ca	; 0x6ca <LED_voidON>
	LED_voidON(DIO_PORTC,led1);
  bc:	67 e0       	ldi	r22, 0x07	; 7
  be:	82 e0       	ldi	r24, 0x02	; 2
  c0:	0e 94 65 03 	call	0x6ca	; 0x6ca <LED_voidON>
	LED_voidON(DIO_PORTD,led2);
  c4:	63 e0       	ldi	r22, 0x03	; 3
  c6:	83 e0       	ldi	r24, 0x03	; 3
  c8:	0e 94 65 03 	call	0x6ca	; 0x6ca <LED_voidON>
void check() {
	
	u8 LOC_u8C = 0, Ptrue = 1, key = 0xff;
	u8 password[] = {1, 2, 3, 4}, userinput[4] = {};
	u8 passwordsize = sizeof(password) / sizeof(password[0]);
	u8 attemptCount = 0; // Counter for wrong attempts
  cc:	10 e0       	ldi	r17, 0x00	; 0
	
	while (1) {
		LOC_u8C = 0;
		Ptrue = 1; // Assume the password is correct initially
		
		LCD_voidSendCommand(1); // Clear screen
  ce:	81 e0       	ldi	r24, 0x01	; 1
  d0:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <LCD_voidSendCommand>
		LCD_voidGotoXY(0, 0);
  d4:	60 e0       	ldi	r22, 0x00	; 0
  d6:	80 e0       	ldi	r24, 0x00	; 0
  d8:	0e 94 33 03 	call	0x666	; 0x666 <LCD_voidGotoXY>
		LCD_voidSendString("Enter Password");
  dc:	88 e7       	ldi	r24, 0x78	; 120
  de:	90 e0       	ldi	r25, 0x00	; 0
  e0:	0e 94 bf 02 	call	0x57e	; 0x57e <LCD_voidSendString>
		LCD_voidGotoXY(0, 1);
  e4:	61 e0       	ldi	r22, 0x01	; 1
  e6:	80 e0       	ldi	r24, 0x00	; 0
  e8:	0e 94 33 03 	call	0x666	; 0x666 <LCD_voidGotoXY>
		LCD_voidSendString(": ");
  ec:	87 e8       	ldi	r24, 0x87	; 135
  ee:	90 e0       	ldi	r25, 0x00	; 0
  f0:	0e 94 bf 02 	call	0x57e	; 0x57e <LCD_voidSendString>
		LCD_voidGotoXY(2, 1);
  f4:	61 e0       	ldi	r22, 0x01	; 1
  f6:	82 e0       	ldi	r24, 0x02	; 2
  f8:	0e 94 33 03 	call	0x666	; 0x666 <LCD_voidGotoXY>
	LED_voidON(DIO_PORTC,led1);
	LED_voidON(DIO_PORTD,led2);
	
	
	while (1) {
		LOC_u8C = 0;
  fc:	00 e0       	ldi	r16, 0x00	; 0
		LCD_voidSendString("Enter Password");
		LCD_voidGotoXY(0, 1);
		LCD_voidSendString(": ");
		LCD_voidGotoXY(2, 1);
		
		while (LOC_u8C < passwordsize) {
  fe:	29 c0       	rjmp	.+82     	; 0x152 <check+0xd0>
			LCD_voidGotoXY(LOC_u8C + 1, 1);
 100:	ff 24       	eor	r15, r15
 102:	f3 94       	inc	r15
 104:	f0 0e       	add	r15, r16
 106:	61 e0       	ldi	r22, 0x01	; 1
 108:	8f 2d       	mov	r24, r15
 10a:	0e 94 33 03 	call	0x666	; 0x666 <LCD_voidGotoXY>
			key = KEYPAD_u8GetKey();
 10e:	0e 94 b8 01 	call	0x370	; 0x370 <KEYPAD_u8GetKey>
			if (key != 0xff) {
 112:	8f 3f       	cpi	r24, 0xFF	; 255
 114:	f1 f0       	breq	.+60     	; 0x152 <check+0xd0>
				userinput[LOC_u8C] = key;
 116:	e5 e0       	ldi	r30, 0x05	; 5
 118:	f0 e0       	ldi	r31, 0x00	; 0
 11a:	ec 0f       	add	r30, r28
 11c:	fd 1f       	adc	r31, r29
 11e:	e0 0f       	add	r30, r16
 120:	f1 1d       	adc	r31, r1
 122:	80 83       	st	Z, r24
				LCD_voidSendNumber(key);
 124:	68 2f       	mov	r22, r24
 126:	70 e0       	ldi	r23, 0x00	; 0
 128:	80 e0       	ldi	r24, 0x00	; 0
 12a:	90 e0       	ldi	r25, 0x00	; 0
 12c:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <LCD_voidSendNumber>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 130:	2f ef       	ldi	r18, 0xFF	; 255
 132:	89 e6       	ldi	r24, 0x69	; 105
 134:	98 e1       	ldi	r25, 0x18	; 24
 136:	21 50       	subi	r18, 0x01	; 1
 138:	80 40       	sbci	r24, 0x00	; 0
 13a:	90 40       	sbci	r25, 0x00	; 0
 13c:	e1 f7       	brne	.-8      	; 0x136 <check+0xb4>
 13e:	00 c0       	rjmp	.+0      	; 0x140 <check+0xbe>
 140:	00 00       	nop
				_delay_ms(500);
				LCD_voidDrawData(0,dot,LOC_u8C + 1, 1);
 142:	21 e0       	ldi	r18, 0x01	; 1
 144:	4f 2d       	mov	r20, r15
 146:	60 e6       	ldi	r22, 0x60	; 96
 148:	70 e0       	ldi	r23, 0x00	; 0
 14a:	80 e0       	ldi	r24, 0x00	; 0
 14c:	0e 94 3b 03 	call	0x676	; 0x676 <LCD_voidDrawData>
				LOC_u8C++;
 150:	0f 2d       	mov	r16, r15
		LCD_voidSendString("Enter Password");
		LCD_voidGotoXY(0, 1);
		LCD_voidSendString(": ");
		LCD_voidGotoXY(2, 1);
		
		while (LOC_u8C < passwordsize) {
 152:	04 30       	cpi	r16, 0x04	; 4
 154:	a8 f2       	brcs	.-86     	; 0x100 <check+0x7e>
				LOC_u8C++;
			}
		}
		
		// Wait for button press connected to PORTB pin 0 to check password
		while (DIO_u8ReadPinVal(DIO_PORTB,DIO_PIN0)==0);
 156:	60 e0       	ldi	r22, 0x00	; 0
 158:	81 e0       	ldi	r24, 0x01	; 1
 15a:	0e 94 a5 04 	call	0x94a	; 0x94a <DIO_u8ReadPinVal>
 15e:	88 23       	and	r24, r24
 160:	d1 f3       	breq	.-12     	; 0x156 <check+0xd4>
 162:	80 e0       	ldi	r24, 0x00	; 0
 164:	90 e0       	ldi	r25, 0x00	; 0
 166:	01 e0       	ldi	r16, 0x01	; 1
 168:	11 c0       	rjmp	.+34     	; 0x18c <check+0x10a>
		
		for (int i = 0; i < passwordsize; i++) {
			if (password[i] != userinput[i]) {
 16a:	e1 e0       	ldi	r30, 0x01	; 1
 16c:	f0 e0       	ldi	r31, 0x00	; 0
 16e:	ec 0f       	add	r30, r28
 170:	fd 1f       	adc	r31, r29
 172:	e8 0f       	add	r30, r24
 174:	f9 1f       	adc	r31, r25
 176:	30 81       	ld	r19, Z
 178:	e5 e0       	ldi	r30, 0x05	; 5
 17a:	f0 e0       	ldi	r31, 0x00	; 0
 17c:	ec 0f       	add	r30, r28
 17e:	fd 1f       	adc	r31, r29
 180:	e8 0f       	add	r30, r24
 182:	f9 1f       	adc	r31, r25
 184:	20 81       	ld	r18, Z
 186:	32 13       	cpse	r19, r18
				Ptrue = 0; // Password is incorrect
 188:	00 e0       	ldi	r16, 0x00	; 0
		}
		
		// Wait for button press connected to PORTB pin 0 to check password
		while (DIO_u8ReadPinVal(DIO_PORTB,DIO_PIN0)==0);
		
		for (int i = 0; i < passwordsize; i++) {
 18a:	01 96       	adiw	r24, 0x01	; 1
 18c:	84 30       	cpi	r24, 0x04	; 4
 18e:	91 05       	cpc	r25, r1
 190:	64 f3       	brlt	.-40     	; 0x16a <check+0xe8>
			if (password[i] != userinput[i]) {
				Ptrue = 0; // Password is incorrect
			}
		}
		
		LCD_voidSendCommand(1); // Clear screen
 192:	81 e0       	ldi	r24, 0x01	; 1
 194:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <LCD_voidSendCommand>
		LCD_voidGotoXY(0, 0);
 198:	60 e0       	ldi	r22, 0x00	; 0
 19a:	80 e0       	ldi	r24, 0x00	; 0
 19c:	0e 94 33 03 	call	0x666	; 0x666 <LCD_voidGotoXY>
		
		if (Ptrue == 1) {
 1a0:	01 30       	cpi	r16, 0x01	; 1
 1a2:	71 f4       	brne	.+28     	; 0x1c0 <check+0x13e>
			LCD_voidSendString("Welcome");
 1a4:	8a e8       	ldi	r24, 0x8A	; 138
 1a6:	90 e0       	ldi	r25, 0x00	; 0
 1a8:	0e 94 bf 02 	call	0x57e	; 0x57e <LCD_voidSendString>
 1ac:	2f ef       	ldi	r18, 0xFF	; 255
 1ae:	87 ea       	ldi	r24, 0xA7	; 167
 1b0:	91 e6       	ldi	r25, 0x61	; 97
 1b2:	21 50       	subi	r18, 0x01	; 1
 1b4:	80 40       	sbci	r24, 0x00	; 0
 1b6:	90 40       	sbci	r25, 0x00	; 0
 1b8:	e1 f7       	brne	.-8      	; 0x1b2 <check+0x130>
 1ba:	00 c0       	rjmp	.+0      	; 0x1bc <check+0x13a>
 1bc:	00 00       	nop
					_delay_ms(200);
				}
			}
		}
	}
}
 1be:	4a c0       	rjmp	.+148    	; 0x254 <check+0x1d2>
		if (Ptrue == 1) {
			LCD_voidSendString("Welcome");
			_delay_ms(2000);
			break; // Exit the loop as password is correct
			} else {
			if(attemptCount==0)		 LED_voidOFF(DIO_PORTC,led0);
 1c0:	11 11       	cpse	r17, r1
 1c2:	05 c0       	rjmp	.+10     	; 0x1ce <check+0x14c>
 1c4:	62 e0       	ldi	r22, 0x02	; 2
 1c6:	82 e0       	ldi	r24, 0x02	; 2
 1c8:	0e 94 74 03 	call	0x6e8	; 0x6e8 <LED_voidOFF>
 1cc:	0d c0       	rjmp	.+26     	; 0x1e8 <check+0x166>
			else if(attemptCount==1) LED_voidOFF(DIO_PORTC,led1);
 1ce:	11 30       	cpi	r17, 0x01	; 1
 1d0:	29 f4       	brne	.+10     	; 0x1dc <check+0x15a>
 1d2:	67 e0       	ldi	r22, 0x07	; 7
 1d4:	82 e0       	ldi	r24, 0x02	; 2
 1d6:	0e 94 74 03 	call	0x6e8	; 0x6e8 <LED_voidOFF>
 1da:	06 c0       	rjmp	.+12     	; 0x1e8 <check+0x166>
			else if(attemptCount==2) LED_voidOFF(DIO_PORTD,led2);
 1dc:	12 30       	cpi	r17, 0x02	; 2
 1de:	21 f4       	brne	.+8      	; 0x1e8 <check+0x166>
 1e0:	63 e0       	ldi	r22, 0x03	; 3
 1e2:	83 e0       	ldi	r24, 0x03	; 3
 1e4:	0e 94 74 03 	call	0x6e8	; 0x6e8 <LED_voidOFF>
			attemptCount++;
 1e8:	1f 5f       	subi	r17, 0xFF	; 255
			LCD_voidSendString("Wrong Password");
 1ea:	82 e9       	ldi	r24, 0x92	; 146
 1ec:	90 e0       	ldi	r25, 0x00	; 0
 1ee:	0e 94 bf 02 	call	0x57e	; 0x57e <LCD_voidSendString>
 1f2:	2f ef       	ldi	r18, 0xFF	; 255
 1f4:	87 ea       	ldi	r24, 0xA7	; 167
 1f6:	91 e6       	ldi	r25, 0x61	; 97
 1f8:	21 50       	subi	r18, 0x01	; 1
 1fa:	80 40       	sbci	r24, 0x00	; 0
 1fc:	90 40       	sbci	r25, 0x00	; 0
 1fe:	e1 f7       	brne	.-8      	; 0x1f8 <check+0x176>
 200:	00 c0       	rjmp	.+0      	; 0x202 <check+0x180>
 202:	00 00       	nop
			_delay_ms(2000);
			
			if (attemptCount >= 3) {
 204:	13 30       	cpi	r17, 0x03	; 3
 206:	08 f4       	brcc	.+2      	; 0x20a <check+0x188>
 208:	62 cf       	rjmp	.-316    	; 0xce <check+0x4c>
				
				LCD_voidSendCommand(1); // Clear screen
 20a:	81 e0       	ldi	r24, 0x01	; 1
 20c:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <LCD_voidSendCommand>
				LCD_voidGotoXY(0, 0);
 210:	60 e0       	ldi	r22, 0x00	; 0
 212:	80 e0       	ldi	r24, 0x00	; 0
 214:	0e 94 33 03 	call	0x666	; 0x666 <LCD_voidGotoXY>
				LCD_voidSendString("Alert!");
 218:	81 ea       	ldi	r24, 0xA1	; 161
 21a:	90 e0       	ldi	r25, 0x00	; 0
 21c:	0e 94 bf 02 	call	0x57e	; 0x57e <LCD_voidSendString>
				while (1){
					LED_voidTOGGLE(DIO_PORTC,DIO_PIN2);
 220:	62 e0       	ldi	r22, 0x02	; 2
 222:	82 e0       	ldi	r24, 0x02	; 2
 224:	0e 94 83 03 	call	0x706	; 0x706 <LED_voidTOGGLE>
					LED_voidTOGGLE(DIO_PORTC,DIO_PIN7);
 228:	67 e0       	ldi	r22, 0x07	; 7
 22a:	82 e0       	ldi	r24, 0x02	; 2
 22c:	0e 94 83 03 	call	0x706	; 0x706 <LED_voidTOGGLE>
					LED_voidTOGGLE(DIO_PORTD,DIO_PIN3);
 230:	63 e0       	ldi	r22, 0x03	; 3
 232:	83 e0       	ldi	r24, 0x03	; 3
 234:	0e 94 83 03 	call	0x706	; 0x706 <LED_voidTOGGLE>
					DIO_voidTogglePinVal(DIO_PORTA,DIO_PIN3);
 238:	63 e0       	ldi	r22, 0x03	; 3
 23a:	80 e0       	ldi	r24, 0x00	; 0
 23c:	0e 94 71 04 	call	0x8e2	; 0x8e2 <DIO_voidTogglePinVal>
 240:	2f ef       	ldi	r18, 0xFF	; 255
 242:	83 ec       	ldi	r24, 0xC3	; 195
 244:	99 e0       	ldi	r25, 0x09	; 9
 246:	21 50       	subi	r18, 0x01	; 1
 248:	80 40       	sbci	r24, 0x00	; 0
 24a:	90 40       	sbci	r25, 0x00	; 0
 24c:	e1 f7       	brne	.-8      	; 0x246 <check+0x1c4>
 24e:	00 c0       	rjmp	.+0      	; 0x250 <check+0x1ce>
 250:	00 00       	nop
 252:	e6 cf       	rjmp	.-52     	; 0x220 <check+0x19e>
					_delay_ms(200);
				}
			}
		}
	}
}
 254:	28 96       	adiw	r28, 0x08	; 8
 256:	0f b6       	in	r0, 0x3f	; 63
 258:	f8 94       	cli
 25a:	de bf       	out	0x3e, r29	; 62
 25c:	0f be       	out	0x3f, r0	; 63
 25e:	cd bf       	out	0x3d, r28	; 61
 260:	df 91       	pop	r29
 262:	cf 91       	pop	r28
 264:	1f 91       	pop	r17
 266:	0f 91       	pop	r16
 268:	ff 90       	pop	r15
 26a:	08 95       	ret

0000026c <main>:
	0x00
};

void main(){
	
		DIO_voidSetPinDir(DIO_PORTA,DIO_PIN3,OUTPUT);
 26c:	41 e0       	ldi	r20, 0x01	; 1
 26e:	63 e0       	ldi	r22, 0x03	; 3
 270:	80 e0       	ldi	r24, 0x00	; 0
 272:	0e 94 91 03 	call	0x722	; 0x722 <DIO_voidSetPinDir>
		DIO_voidSetPinDir(DIO_PORTC,DIO_PIN2,OUTPUT);
 276:	41 e0       	ldi	r20, 0x01	; 1
 278:	62 e0       	ldi	r22, 0x02	; 2
 27a:	82 e0       	ldi	r24, 0x02	; 2
 27c:	0e 94 91 03 	call	0x722	; 0x722 <DIO_voidSetPinDir>
		DIO_voidSetPinDir(DIO_PORTC,DIO_PIN7,OUTPUT);
 280:	41 e0       	ldi	r20, 0x01	; 1
 282:	67 e0       	ldi	r22, 0x07	; 7
 284:	82 e0       	ldi	r24, 0x02	; 2
 286:	0e 94 91 03 	call	0x722	; 0x722 <DIO_voidSetPinDir>
		DIO_voidSetPinDir(DIO_PORTD,DIO_PIN3,OUTPUT);
 28a:	41 e0       	ldi	r20, 0x01	; 1
 28c:	63 e0       	ldi	r22, 0x03	; 3
 28e:	83 e0       	ldi	r24, 0x03	; 3
 290:	0e 94 91 03 	call	0x722	; 0x722 <DIO_voidSetPinDir>
		//DIO_voidSetPortVal(DIO_PORTC,0x84);
		
		DIO_voidSetPinDir(DIO_PORTB,DIO_PIN0,INPUT);
 294:	40 e0       	ldi	r20, 0x00	; 0
 296:	60 e0       	ldi	r22, 0x00	; 0
 298:	81 e0       	ldi	r24, 0x01	; 1
 29a:	0e 94 91 03 	call	0x722	; 0x722 <DIO_voidSetPinDir>
		DIO_voidSetPinVal(DIO_PORTB,DIO_PIN0,LOW);
 29e:	40 e0       	ldi	r20, 0x00	; 0
 2a0:	60 e0       	ldi	r22, 0x00	; 0
 2a2:	81 e0       	ldi	r24, 0x01	; 1
 2a4:	0e 94 01 04 	call	0x802	; 0x802 <DIO_voidSetPinVal>
		
		DIO_voidSetPortDir(LCD_DPORT,0xf0);
 2a8:	60 ef       	ldi	r22, 0xF0	; 240
 2aa:	80 e0       	ldi	r24, 0x00	; 0
 2ac:	0e 94 d3 04 	call	0x9a6	; 0x9a6 <DIO_voidSetPortDir>
		DIO_voidSetPortDir(LCD_CPORT,0x0E);
 2b0:	6e e0       	ldi	r22, 0x0E	; 14
 2b2:	81 e0       	ldi	r24, 0x01	; 1
 2b4:	0e 94 d3 04 	call	0x9a6	; 0x9a6 <DIO_voidSetPortDir>
		LCD_voidInit();
 2b8:	0e 94 86 02 	call	0x50c	; 0x50c <LCD_voidInit>
		
		
		KEYPAD_voidInit();
 2bc:	0e 94 67 01 	call	0x2ce	; 0x2ce <KEYPAD_voidInit>
		
		LED_voidON(DIO_PORTB,DIO_PIN2);
 2c0:	62 e0       	ldi	r22, 0x02	; 2
 2c2:	81 e0       	ldi	r24, 0x01	; 1
 2c4:	0e 94 65 03 	call	0x6ca	; 0x6ca <LED_voidON>
		//while(1){
			check();
 2c8:	0e 94 41 00 	call	0x82	; 0x82 <check>
 2cc:	08 95       	ret

000002ce <KEYPAD_voidInit>:
					      {'C',0,'=','/'}} ; 




void KEYPAD_voidInit(void){
 2ce:	ff 92       	push	r15
 2d0:	0f 93       	push	r16
 2d2:	1f 93       	push	r17
 2d4:	cf 93       	push	r28
 2d6:	df 93       	push	r29
 2d8:	cd b7       	in	r28, 0x3d	; 61
 2da:	de b7       	in	r29, 0x3e	; 62
 2dc:	28 97       	sbiw	r28, 0x08	; 8
 2de:	0f b6       	in	r0, 0x3f	; 63
 2e0:	f8 94       	cli
 2e2:	de bf       	out	0x3e, r29	; 62
 2e4:	0f be       	out	0x3f, r0	; 63
 2e6:	cd bf       	out	0x3d, r28	; 61
	
	    u8 COL_ARR[4]={KEYPAD_C0_PIN,KEYPAD_C1_PIN,KEYPAD_C2_PIN,KEYPAD_C3_PIN} ; 
 2e8:	24 e0       	ldi	r18, 0x04	; 4
 2ea:	29 83       	std	Y+1, r18	; 0x01
 2ec:	95 e0       	ldi	r25, 0x05	; 5
 2ee:	9a 83       	std	Y+2, r25	; 0x02
 2f0:	86 e0       	ldi	r24, 0x06	; 6
 2f2:	8b 83       	std	Y+3, r24	; 0x03
 2f4:	37 e0       	ldi	r19, 0x07	; 7
 2f6:	3c 83       	std	Y+4, r19	; 0x04
	    u8 ROW_ARR[4]={KEYPAD_R0_PIN,KEYPAD_R1_PIN,KEYPAD_R2_PIN,KEYPAD_R3_PIN} ;
 2f8:	33 e0       	ldi	r19, 0x03	; 3
 2fa:	3d 83       	std	Y+5, r19	; 0x05
 2fc:	2e 83       	std	Y+6, r18	; 0x06
 2fe:	9f 83       	std	Y+7, r25	; 0x07
 300:	88 87       	std	Y+8, r24	; 0x08
	    
	     u8 LOCu8row=0 , LOC_u8col=0 ; 
		 
		 for (LOC_u8col=0 , LOCu8row=0 ; LOCu8row<4 && LOC_u8col<4 ; LOC_u8col++,LOCu8row++)
 302:	00 e0       	ldi	r16, 0x00	; 0
 304:	10 e0       	ldi	r17, 0x00	; 0
 306:	24 c0       	rjmp	.+72     	; 0x350 <KEYPAD_voidInit+0x82>
		 {
			 
			 /* make rows pins as input & active internal pull up */
			 DIO_voidSetPinDir(KEYPAD_ROW_PORT,ROW_ARR[LOCu8row],INPUT) ; 
 308:	e5 e0       	ldi	r30, 0x05	; 5
 30a:	f0 e0       	ldi	r31, 0x00	; 0
 30c:	ec 0f       	add	r30, r28
 30e:	fd 1f       	adc	r31, r29
 310:	e1 0f       	add	r30, r17
 312:	f1 1d       	adc	r31, r1
 314:	f0 80       	ld	r15, Z
 316:	40 e0       	ldi	r20, 0x00	; 0
 318:	6f 2d       	mov	r22, r15
 31a:	82 e0       	ldi	r24, 0x02	; 2
 31c:	0e 94 91 03 	call	0x722	; 0x722 <DIO_voidSetPinDir>
			 DIO_voidSetPinVal(KEYPAD_ROW_PORT,ROW_ARR[LOCu8row],HIGH) ; 
 320:	41 e0       	ldi	r20, 0x01	; 1
 322:	6f 2d       	mov	r22, r15
 324:	82 e0       	ldi	r24, 0x02	; 2
 326:	0e 94 01 04 	call	0x802	; 0x802 <DIO_voidSetPinVal>
			 
			 /*make colums as output high */
			 
			 DIO_voidSetPinDir(KEYPAD_COL_PORT,COL_ARR[LOC_u8col],OUTPUT) ; 
 32a:	e1 e0       	ldi	r30, 0x01	; 1
 32c:	f0 e0       	ldi	r31, 0x00	; 0
 32e:	ec 0f       	add	r30, r28
 330:	fd 1f       	adc	r31, r29
 332:	e0 0f       	add	r30, r16
 334:	f1 1d       	adc	r31, r1
 336:	f0 80       	ld	r15, Z
 338:	41 e0       	ldi	r20, 0x01	; 1
 33a:	6f 2d       	mov	r22, r15
 33c:	81 e0       	ldi	r24, 0x01	; 1
 33e:	0e 94 91 03 	call	0x722	; 0x722 <DIO_voidSetPinDir>
			 DIO_voidSetPinVal(KEYPAD_COL_PORT,COL_ARR[LOC_u8col],HIGH)  ; 
 342:	41 e0       	ldi	r20, 0x01	; 1
 344:	6f 2d       	mov	r22, r15
 346:	81 e0       	ldi	r24, 0x01	; 1
 348:	0e 94 01 04 	call	0x802	; 0x802 <DIO_voidSetPinVal>
	    u8 COL_ARR[4]={KEYPAD_C0_PIN,KEYPAD_C1_PIN,KEYPAD_C2_PIN,KEYPAD_C3_PIN} ; 
	    u8 ROW_ARR[4]={KEYPAD_R0_PIN,KEYPAD_R1_PIN,KEYPAD_R2_PIN,KEYPAD_R3_PIN} ;
	    
	     u8 LOCu8row=0 , LOC_u8col=0 ; 
		 
		 for (LOC_u8col=0 , LOCu8row=0 ; LOCu8row<4 && LOC_u8col<4 ; LOC_u8col++,LOCu8row++)
 34c:	0f 5f       	subi	r16, 0xFF	; 255
 34e:	1f 5f       	subi	r17, 0xFF	; 255
 350:	14 30       	cpi	r17, 0x04	; 4
 352:	10 f4       	brcc	.+4      	; 0x358 <KEYPAD_voidInit+0x8a>
 354:	04 30       	cpi	r16, 0x04	; 4
 356:	c0 f2       	brcs	.-80     	; 0x308 <KEYPAD_voidInit+0x3a>
	
	
	
	
	
}
 358:	28 96       	adiw	r28, 0x08	; 8
 35a:	0f b6       	in	r0, 0x3f	; 63
 35c:	f8 94       	cli
 35e:	de bf       	out	0x3e, r29	; 62
 360:	0f be       	out	0x3f, r0	; 63
 362:	cd bf       	out	0x3d, r28	; 61
 364:	df 91       	pop	r29
 366:	cf 91       	pop	r28
 368:	1f 91       	pop	r17
 36a:	0f 91       	pop	r16
 36c:	ff 90       	pop	r15
 36e:	08 95       	ret

00000370 <KEYPAD_u8GetKey>:

u8 KEYPAD_u8GetKey(void){
 370:	af 92       	push	r10
 372:	bf 92       	push	r11
 374:	cf 92       	push	r12
 376:	df 92       	push	r13
 378:	ef 92       	push	r14
 37a:	ff 92       	push	r15
 37c:	0f 93       	push	r16
 37e:	1f 93       	push	r17
 380:	cf 93       	push	r28
 382:	df 93       	push	r29
 384:	cd b7       	in	r28, 0x3d	; 61
 386:	de b7       	in	r29, 0x3e	; 62
 388:	28 97       	sbiw	r28, 0x08	; 8
 38a:	0f b6       	in	r0, 0x3f	; 63
 38c:	f8 94       	cli
 38e:	de bf       	out	0x3e, r29	; 62
 390:	0f be       	out	0x3f, r0	; 63
 392:	cd bf       	out	0x3d, r28	; 61
	
	 u8 COL_ARR[4]={KEYPAD_C0_PIN,KEYPAD_C1_PIN,KEYPAD_C2_PIN,KEYPAD_C3_PIN} ;
 394:	24 e0       	ldi	r18, 0x04	; 4
 396:	29 83       	std	Y+1, r18	; 0x01
 398:	95 e0       	ldi	r25, 0x05	; 5
 39a:	9a 83       	std	Y+2, r25	; 0x02
 39c:	86 e0       	ldi	r24, 0x06	; 6
 39e:	8b 83       	std	Y+3, r24	; 0x03
 3a0:	37 e0       	ldi	r19, 0x07	; 7
 3a2:	3c 83       	std	Y+4, r19	; 0x04
	 u8 ROW_ARR[4]={KEYPAD_R0_PIN,KEYPAD_R1_PIN,KEYPAD_R2_PIN,KEYPAD_R3_PIN} ;
 3a4:	33 e0       	ldi	r19, 0x03	; 3
 3a6:	3d 83       	std	Y+5, r19	; 0x05
 3a8:	2e 83       	std	Y+6, r18	; 0x06
 3aa:	9f 83       	std	Y+7, r25	; 0x07
 3ac:	88 87       	std	Y+8, r24	; 0x08
	 
	 u8 LOCu8row=0 , LOC_u8col=0 ;
	 
	 u8 LOC_u8val=0xff ; 
	 
	 for (LOC_u8col=0 ; LOC_u8col<4 ;LOC_u8col++)
 3ae:	b1 2c       	mov	r11, r1
 3b0:	3b c0       	rjmp	.+118    	; 0x428 <__EEPROM_REGION_LENGTH__+0x28>
	 {
		 /* set col(n) ---> low */
		 DIO_voidSetPinVal(KEYPAD_COL_PORT,COL_ARR[LOC_u8col],LOW) ; 
 3b2:	cb 2c       	mov	r12, r11
 3b4:	d1 2c       	mov	r13, r1
 3b6:	e1 e0       	ldi	r30, 0x01	; 1
 3b8:	f0 e0       	ldi	r31, 0x00	; 0
 3ba:	ec 0f       	add	r30, r28
 3bc:	fd 1f       	adc	r31, r29
 3be:	ec 0d       	add	r30, r12
 3c0:	fd 1d       	adc	r31, r13
 3c2:	a0 80       	ld	r10, Z
 3c4:	40 e0       	ldi	r20, 0x00	; 0
 3c6:	6a 2d       	mov	r22, r10
 3c8:	81 e0       	ldi	r24, 0x01	; 1
 3ca:	0e 94 01 04 	call	0x802	; 0x802 <DIO_voidSetPinVal>
		 
		 for(LOCu8row=0 ; LOCu8row<4;LOCu8row++){
 3ce:	10 e0       	ldi	r17, 0x00	; 0
 3d0:	23 c0       	rjmp	.+70     	; 0x418 <__EEPROM_REGION_LENGTH__+0x18>
			 
			 
			 /* CHECK IF  button is pressed */
			 
			   if(DIO_u8ReadPinVal(KEYPAD_ROW_PORT,ROW_ARR[LOCu8row])==0){
 3d2:	e1 2e       	mov	r14, r17
 3d4:	f1 2c       	mov	r15, r1
 3d6:	e5 e0       	ldi	r30, 0x05	; 5
 3d8:	f0 e0       	ldi	r31, 0x00	; 0
 3da:	ec 0f       	add	r30, r28
 3dc:	fd 1f       	adc	r31, r29
 3de:	ee 0d       	add	r30, r14
 3e0:	ff 1d       	adc	r31, r15
 3e2:	00 81       	ld	r16, Z
 3e4:	60 2f       	mov	r22, r16
 3e6:	82 e0       	ldi	r24, 0x02	; 2
 3e8:	0e 94 a5 04 	call	0x94a	; 0x94a <DIO_u8ReadPinVal>
 3ec:	81 11       	cpse	r24, r1
 3ee:	13 c0       	rjmp	.+38     	; 0x416 <__EEPROM_REGION_LENGTH__+0x16>
				   
				   
				   LOC_u8val=KEYPAD_DATA_ARR[LOCu8row][LOC_u8col] ; 
 3f0:	c7 01       	movw	r24, r14
 3f2:	88 0f       	add	r24, r24
 3f4:	99 1f       	adc	r25, r25
 3f6:	88 0f       	add	r24, r24
 3f8:	99 1f       	adc	r25, r25
 3fa:	88 59       	subi	r24, 0x98	; 152
 3fc:	9f 4f       	sbci	r25, 0xFF	; 255
 3fe:	fc 01       	movw	r30, r24
 400:	ec 0d       	add	r30, r12
 402:	fd 1d       	adc	r31, r13
 404:	10 81       	ld	r17, Z
				   
				   while(DIO_u8ReadPinVal(KEYPAD_ROW_PORT,ROW_ARR[LOCu8row])==0) ; 
 406:	60 2f       	mov	r22, r16
 408:	82 e0       	ldi	r24, 0x02	; 2
 40a:	0e 94 a5 04 	call	0x94a	; 0x94a <DIO_u8ReadPinVal>
 40e:	88 23       	and	r24, r24
 410:	d1 f3       	breq	.-12     	; 0x406 <__EEPROM_REGION_LENGTH__+0x6>
				   
				   return LOC_u8val ; 
 412:	81 2f       	mov	r24, r17
 414:	0d c0       	rjmp	.+26     	; 0x430 <__EEPROM_REGION_LENGTH__+0x30>
	 for (LOC_u8col=0 ; LOC_u8col<4 ;LOC_u8col++)
	 {
		 /* set col(n) ---> low */
		 DIO_voidSetPinVal(KEYPAD_COL_PORT,COL_ARR[LOC_u8col],LOW) ; 
		 
		 for(LOCu8row=0 ; LOCu8row<4;LOCu8row++){
 416:	1f 5f       	subi	r17, 0xFF	; 255
 418:	14 30       	cpi	r17, 0x04	; 4
 41a:	d8 f2       	brcs	.-74     	; 0x3d2 <KEYPAD_u8GetKey+0x62>
			   }
			 
			 
		 }
		  /* set col(n) ---> HIGH */
		  DIO_voidSetPinVal(KEYPAD_COL_PORT,COL_ARR[LOC_u8col],HIGH) ;
 41c:	41 e0       	ldi	r20, 0x01	; 1
 41e:	6a 2d       	mov	r22, r10
 420:	81 e0       	ldi	r24, 0x01	; 1
 422:	0e 94 01 04 	call	0x802	; 0x802 <DIO_voidSetPinVal>
	 
	 u8 LOCu8row=0 , LOC_u8col=0 ;
	 
	 u8 LOC_u8val=0xff ; 
	 
	 for (LOC_u8col=0 ; LOC_u8col<4 ;LOC_u8col++)
 426:	b3 94       	inc	r11
 428:	83 e0       	ldi	r24, 0x03	; 3
 42a:	8b 15       	cp	r24, r11
 42c:	10 f6       	brcc	.-124    	; 0x3b2 <KEYPAD_u8GetKey+0x42>
	
	
	
	
	
	return LOC_u8val ; 
 42e:	8f ef       	ldi	r24, 0xFF	; 255
	
}
 430:	28 96       	adiw	r28, 0x08	; 8
 432:	0f b6       	in	r0, 0x3f	; 63
 434:	f8 94       	cli
 436:	de bf       	out	0x3e, r29	; 62
 438:	0f be       	out	0x3f, r0	; 63
 43a:	cd bf       	out	0x3d, r28	; 61
 43c:	df 91       	pop	r29
 43e:	cf 91       	pop	r28
 440:	1f 91       	pop	r17
 442:	0f 91       	pop	r16
 444:	ff 90       	pop	r15
 446:	ef 90       	pop	r14
 448:	df 90       	pop	r13
 44a:	cf 90       	pop	r12
 44c:	bf 90       	pop	r11
 44e:	af 90       	pop	r10
 450:	08 95       	ret

00000452 <LCD_voidSHData>:
#define  F_CPU 16000000UL 
#include <util/delay.h>



static void LCD_voidSHData(u8 copy_u8data){
 452:	0f 93       	push	r16
 454:	1f 93       	push	r17
 456:	cf 93       	push	r28
 458:	df 93       	push	r29
 45a:	00 d0       	rcall	.+0      	; 0x45c <LCD_voidSHData+0xa>
 45c:	00 d0       	rcall	.+0      	; 0x45e <LCD_voidSHData+0xc>
 45e:	cd b7       	in	r28, 0x3d	; 61
 460:	de b7       	in	r29, 0x3e	; 62
 462:	08 2f       	mov	r16, r24
	
	 u8 LOC_u8LcdPins[4]={LCD_D4_PIN,LCD_D5_PIN,LCD_D6_PIN,LCD_D7_PIN} ; 
 464:	84 e0       	ldi	r24, 0x04	; 4
 466:	89 83       	std	Y+1, r24	; 0x01
 468:	85 e0       	ldi	r24, 0x05	; 5
 46a:	8a 83       	std	Y+2, r24	; 0x02
 46c:	86 e0       	ldi	r24, 0x06	; 6
 46e:	8b 83       	std	Y+3, r24	; 0x03
 470:	87 e0       	ldi	r24, 0x07	; 7
 472:	8c 83       	std	Y+4, r24	; 0x04
	 u8 loc_in=0 ; 
	 
	 for (loc_in=0 ; loc_in<4;loc_in++)
 474:	10 e0       	ldi	r17, 0x00	; 0
 476:	14 c0       	rjmp	.+40     	; 0x4a0 <LCD_voidSHData+0x4e>
	 {
															  
		 DIO_voidSetPinVal(LCD_DPORT,LOC_u8LcdPins[loc_in],GET_BIT(copy_u8data,loc_in)) ; 
 478:	40 2f       	mov	r20, r16
 47a:	50 e0       	ldi	r21, 0x00	; 0
 47c:	01 2e       	mov	r0, r17
 47e:	02 c0       	rjmp	.+4      	; 0x484 <LCD_voidSHData+0x32>
 480:	55 95       	asr	r21
 482:	47 95       	ror	r20
 484:	0a 94       	dec	r0
 486:	e2 f7       	brpl	.-8      	; 0x480 <LCD_voidSHData+0x2e>
 488:	41 70       	andi	r20, 0x01	; 1
 48a:	e1 e0       	ldi	r30, 0x01	; 1
 48c:	f0 e0       	ldi	r31, 0x00	; 0
 48e:	ec 0f       	add	r30, r28
 490:	fd 1f       	adc	r31, r29
 492:	e1 0f       	add	r30, r17
 494:	f1 1d       	adc	r31, r1
 496:	60 81       	ld	r22, Z
 498:	80 e0       	ldi	r24, 0x00	; 0
 49a:	0e 94 01 04 	call	0x802	; 0x802 <DIO_voidSetPinVal>
static void LCD_voidSHData(u8 copy_u8data){
	
	 u8 LOC_u8LcdPins[4]={LCD_D4_PIN,LCD_D5_PIN,LCD_D6_PIN,LCD_D7_PIN} ; 
	 u8 loc_in=0 ; 
	 
	 for (loc_in=0 ; loc_in<4;loc_in++)
 49e:	1f 5f       	subi	r17, 0xFF	; 255
 4a0:	14 30       	cpi	r17, 0x04	; 4
 4a2:	50 f3       	brcs	.-44     	; 0x478 <LCD_voidSHData+0x26>
	 {
															  
		 DIO_voidSetPinVal(LCD_DPORT,LOC_u8LcdPins[loc_in],GET_BIT(copy_u8data,loc_in)) ; 
		 
	 }
}
 4a4:	0f 90       	pop	r0
 4a6:	0f 90       	pop	r0
 4a8:	0f 90       	pop	r0
 4aa:	0f 90       	pop	r0
 4ac:	df 91       	pop	r29
 4ae:	cf 91       	pop	r28
 4b0:	1f 91       	pop	r17
 4b2:	0f 91       	pop	r16
 4b4:	08 95       	ret

000004b6 <LCD_voidSendEnablePluse>:

void LCD_voidSendEnablePluse(){
	
	  /*send enable pluse */
	  DIO_voidSetPinVal(LCD_CPORT,LCD_E_PIN,HIGH) ;
 4b6:	41 e0       	ldi	r20, 0x01	; 1
 4b8:	63 e0       	ldi	r22, 0x03	; 3
 4ba:	81 e0       	ldi	r24, 0x01	; 1
 4bc:	0e 94 01 04 	call	0x802	; 0x802 <DIO_voidSetPinVal>
 4c0:	8f e3       	ldi	r24, 0x3F	; 63
 4c2:	9f e1       	ldi	r25, 0x1F	; 31
 4c4:	01 97       	sbiw	r24, 0x01	; 1
 4c6:	f1 f7       	brne	.-4      	; 0x4c4 <LCD_voidSendEnablePluse+0xe>
 4c8:	00 c0       	rjmp	.+0      	; 0x4ca <LCD_voidSendEnablePluse+0x14>
 4ca:	00 00       	nop
	  _delay_ms(2) ;
	  DIO_voidSetPinVal(LCD_CPORT,LCD_E_PIN,LOW) ;
 4cc:	40 e0       	ldi	r20, 0x00	; 0
 4ce:	63 e0       	ldi	r22, 0x03	; 3
 4d0:	81 e0       	ldi	r24, 0x01	; 1
 4d2:	0e 94 01 04 	call	0x802	; 0x802 <DIO_voidSetPinVal>
 4d6:	08 95       	ret

000004d8 <LCD_voidSendCommand>:
	
	
}


void LCD_voidSendCommand(u8 copy_u8command){
 4d8:	cf 93       	push	r28
 4da:	c8 2f       	mov	r28, r24
	
	/* set RS PIN as LOW TO SEND COMMAND */
	DIO_voidSetPinVal(LCD_CPORT,LCD_RS_PIN,LOW) ; 
 4dc:	40 e0       	ldi	r20, 0x00	; 0
 4de:	61 e0       	ldi	r22, 0x01	; 1
 4e0:	81 e0       	ldi	r24, 0x01	; 1
 4e2:	0e 94 01 04 	call	0x802	; 0x802 <DIO_voidSetPinVal>
	/* set rw pin as low to write command */
	DIO_voidSetPinVal(LCD_CPORT,LCD_RW_PIN,LOW) ;
 4e6:	40 e0       	ldi	r20, 0x00	; 0
 4e8:	62 e0       	ldi	r22, 0x02	; 2
 4ea:	81 e0       	ldi	r24, 0x01	; 1
 4ec:	0e 94 01 04 	call	0x802	; 0x802 <DIO_voidSetPinVal>
	#if LCD_MODE == LCD_8BIT_MODE 
	/*send command  */
	DIO_voidSetPortVal(LCD_DPORT,copy_u8command) ; 
	  LCD_voidSendEnablePluse() ; 
	#elif LCD_MODE == LCD_4BIT_MODE 
	   LCD_voidSHData(copy_u8command>>4) ; 
 4f0:	8c 2f       	mov	r24, r28
 4f2:	82 95       	swap	r24
 4f4:	8f 70       	andi	r24, 0x0F	; 15
 4f6:	0e 94 29 02 	call	0x452	; 0x452 <LCD_voidSHData>
	  LCD_voidSendEnablePluse() ;
 4fa:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <LCD_voidSendEnablePluse>
	   LCD_voidSHData(copy_u8command) ;
 4fe:	8c 2f       	mov	r24, r28
 500:	0e 94 29 02 	call	0x452	; 0x452 <LCD_voidSHData>
	  LCD_voidSendEnablePluse() ;
 504:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <LCD_voidSendEnablePluse>
	  #endif
	  
	
}
 508:	cf 91       	pop	r28
 50a:	08 95       	ret

0000050c <LCD_voidInit>:
 50c:	2f ef       	ldi	r18, 0xFF	; 255
 50e:	83 ef       	ldi	r24, 0xF3	; 243
 510:	91 e0       	ldi	r25, 0x01	; 1
 512:	21 50       	subi	r18, 0x01	; 1
 514:	80 40       	sbci	r24, 0x00	; 0
 516:	90 40       	sbci	r25, 0x00	; 0
 518:	e1 f7       	brne	.-8      	; 0x512 <LCD_voidInit+0x6>
 51a:	00 c0       	rjmp	.+0      	; 0x51c <LCD_voidInit+0x10>
 51c:	00 00       	nop
	 #if LCD_MODE ==LCD_8BIT_MODE
	/* send function set command */
	LCD_voidSendCommand(0x38) ; 
	
	#elif LCD_MODE == LCD_4BIT_MODE 
	   LCD_voidSHData(0b0010) ; 
 51e:	82 e0       	ldi	r24, 0x02	; 2
 520:	0e 94 29 02 	call	0x452	; 0x452 <LCD_voidSHData>
	   LCD_voidSendEnablePluse() ; 
 524:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <LCD_voidSendEnablePluse>
	   LCD_voidSHData(0b0010) ;
 528:	82 e0       	ldi	r24, 0x02	; 2
 52a:	0e 94 29 02 	call	0x452	; 0x452 <LCD_voidSHData>
	   LCD_voidSendEnablePluse() ;
 52e:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <LCD_voidSendEnablePluse>
	   LCD_voidSHData(0b1000) ; 
 532:	88 e0       	ldi	r24, 0x08	; 8
 534:	0e 94 29 02 	call	0x452	; 0x452 <LCD_voidSHData>
	   LCD_voidSendEnablePluse() ;
 538:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <LCD_voidSendEnablePluse>
	   #endif
	
	/* send  display ON/OFF command */
	LCD_voidSendCommand(0x0C) ; 
 53c:	8c e0       	ldi	r24, 0x0C	; 12
 53e:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <LCD_voidSendCommand>
	/* Send CLR command */
	LCD_voidSendCommand(1) ; 
 542:	81 e0       	ldi	r24, 0x01	; 1
 544:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <LCD_voidSendCommand>
 548:	08 95       	ret

0000054a <LCD_voidSendData>:
}




void LCD_voidSendData(u8 copy_u8data){
 54a:	cf 93       	push	r28
 54c:	c8 2f       	mov	r28, r24

	/* set RS PIN as HIGH TO SEND DATA */
	DIO_voidSetPinVal(LCD_CPORT,LCD_RS_PIN,HIGH) ;
 54e:	41 e0       	ldi	r20, 0x01	; 1
 550:	61 e0       	ldi	r22, 0x01	; 1
 552:	81 e0       	ldi	r24, 0x01	; 1
 554:	0e 94 01 04 	call	0x802	; 0x802 <DIO_voidSetPinVal>
	/* set rw pin as low to write command */
	DIO_voidSetPinVal(LCD_CPORT,LCD_RW_PIN,LOW) ;
 558:	40 e0       	ldi	r20, 0x00	; 0
 55a:	62 e0       	ldi	r22, 0x02	; 2
 55c:	81 e0       	ldi	r24, 0x01	; 1
 55e:	0e 94 01 04 	call	0x802	; 0x802 <DIO_voidSetPinVal>
	#if LCD_MODE == LCD_8BIT_MODE
	/*send command  */
	DIO_voidSetPortVal(LCD_DPORT,copy_u8data) ;
	LCD_voidSendEnablePluse() ;
	#elif LCD_MODE == LCD_4BIT_MODE
	LCD_voidSHData(copy_u8data>>4) ;
 562:	8c 2f       	mov	r24, r28
 564:	82 95       	swap	r24
 566:	8f 70       	andi	r24, 0x0F	; 15
 568:	0e 94 29 02 	call	0x452	; 0x452 <LCD_voidSHData>
	LCD_voidSendEnablePluse() ;
 56c:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <LCD_voidSendEnablePluse>
	LCD_voidSHData(copy_u8data) ;
 570:	8c 2f       	mov	r24, r28
 572:	0e 94 29 02 	call	0x452	; 0x452 <LCD_voidSHData>
	LCD_voidSendEnablePluse() ;
 576:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <LCD_voidSendEnablePluse>
	#endif
	
	
}
 57a:	cf 91       	pop	r28
 57c:	08 95       	ret

0000057e <LCD_voidSendString>:


void LCD_voidSendString(u8 *str){
 57e:	0f 93       	push	r16
 580:	1f 93       	push	r17
 582:	cf 93       	push	r28
 584:	8c 01       	movw	r16, r24
	
	 u8 i=0 ; 
 586:	c0 e0       	ldi	r28, 0x00	; 0
	
	 while(str[i] != '\0')      /* fathi  ----> f a t h i  \0 */
 588:	03 c0       	rjmp	.+6      	; 0x590 <LCD_voidSendString+0x12>
	  {
		  LCD_voidSendData(str[i]) ; 
 58a:	0e 94 a5 02 	call	0x54a	; 0x54a <LCD_voidSendData>
		  i++ ; 
 58e:	cf 5f       	subi	r28, 0xFF	; 255

void LCD_voidSendString(u8 *str){
	
	 u8 i=0 ; 
	
	 while(str[i] != '\0')      /* fathi  ----> f a t h i  \0 */
 590:	f8 01       	movw	r30, r16
 592:	ec 0f       	add	r30, r28
 594:	f1 1d       	adc	r31, r1
 596:	80 81       	ld	r24, Z
 598:	81 11       	cpse	r24, r1
 59a:	f7 cf       	rjmp	.-18     	; 0x58a <LCD_voidSendString+0xc>
	  {
		  LCD_voidSendData(str[i]) ; 
		  i++ ; 
	  }
}
 59c:	cf 91       	pop	r28
 59e:	1f 91       	pop	r17
 5a0:	0f 91       	pop	r16
 5a2:	08 95       	ret

000005a4 <LCD_voidSendNumber>:



void LCD_voidSendNumber(u32 number) {
 5a4:	1f 93       	push	r17
 5a6:	cf 93       	push	r28
 5a8:	df 93       	push	r29
 5aa:	cd b7       	in	r28, 0x3d	; 61
 5ac:	de b7       	in	r29, 0x3e	; 62
 5ae:	2a 97       	sbiw	r28, 0x0a	; 10
 5b0:	0f b6       	in	r0, 0x3f	; 63
 5b2:	f8 94       	cli
 5b4:	de bf       	out	0x3e, r29	; 62
 5b6:	0f be       	out	0x3f, r0	; 63
 5b8:	cd bf       	out	0x3d, r28	; 61
	u8 NumArray[10];   
	u8 NumPointer = 0; 
	
	
	if (number == 0)
 5ba:	61 15       	cp	r22, r1
 5bc:	71 05       	cpc	r23, r1
 5be:	81 05       	cpc	r24, r1
 5c0:	91 05       	cpc	r25, r1
 5c2:	c1 f4       	brne	.+48     	; 0x5f4 <LCD_voidSendNumber+0x50>
	{
		NumArray[NumPointer++] = '0'; // if number = 0 store 0 ascii '48' in the array
 5c4:	80 e3       	ldi	r24, 0x30	; 48
 5c6:	89 83       	std	Y+1, r24	; 0x01
 5c8:	11 e0       	ldi	r17, 0x01	; 1
 5ca:	1a c0       	rjmp	.+52     	; 0x600 <LCD_voidSendNumber+0x5c>
	} 
	else 
	{
		while (number != 0) {
			NumArray[NumPointer++] = (number % 10) + '0'; // using mod to get the most right digit
 5cc:	2a e0       	ldi	r18, 0x0A	; 10
 5ce:	30 e0       	ldi	r19, 0x00	; 0
 5d0:	40 e0       	ldi	r20, 0x00	; 0
 5d2:	50 e0       	ldi	r21, 0x00	; 0
 5d4:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <__udivmodsi4>
 5d8:	e1 e0       	ldi	r30, 0x01	; 1
 5da:	f0 e0       	ldi	r31, 0x00	; 0
 5dc:	ec 0f       	add	r30, r28
 5de:	fd 1f       	adc	r31, r29
 5e0:	e1 0f       	add	r30, r17
 5e2:	f1 1d       	adc	r31, r1
 5e4:	60 5d       	subi	r22, 0xD0	; 208
 5e6:	60 83       	st	Z, r22
			number /= 10; 
 5e8:	62 2f       	mov	r22, r18
 5ea:	73 2f       	mov	r23, r19
 5ec:	84 2f       	mov	r24, r20
 5ee:	95 2f       	mov	r25, r21
		NumArray[NumPointer++] = '0'; // if number = 0 store 0 ascii '48' in the array
	} 
	else 
	{
		while (number != 0) {
			NumArray[NumPointer++] = (number % 10) + '0'; // using mod to get the most right digit
 5f0:	1f 5f       	subi	r17, 0xFF	; 255
 5f2:	01 c0       	rjmp	.+2      	; 0x5f6 <LCD_voidSendNumber+0x52>
 5f4:	10 e0       	ldi	r17, 0x00	; 0
	{
		NumArray[NumPointer++] = '0'; // if number = 0 store 0 ascii '48' in the array
	} 
	else 
	{
		while (number != 0) {
 5f6:	61 15       	cp	r22, r1
 5f8:	71 05       	cpc	r23, r1
 5fa:	81 05       	cpc	r24, r1
 5fc:	91 05       	cpc	r25, r1
 5fe:	31 f7       	brne	.-52     	; 0x5cc <LCD_voidSendNumber+0x28>
			number /= 10; 
		}
	}

	// reverse the array
	for (u8 i = 0; i < NumPointer / 2; i++) 
 600:	80 e0       	ldi	r24, 0x00	; 0
 602:	18 c0       	rjmp	.+48     	; 0x634 <LCD_voidSendNumber+0x90>
	{
		u8 temp = NumArray[i];
 604:	28 2f       	mov	r18, r24
 606:	30 e0       	ldi	r19, 0x00	; 0
 608:	a1 e0       	ldi	r26, 0x01	; 1
 60a:	b0 e0       	ldi	r27, 0x00	; 0
 60c:	ac 0f       	add	r26, r28
 60e:	bd 1f       	adc	r27, r29
 610:	a2 0f       	add	r26, r18
 612:	b3 1f       	adc	r27, r19
 614:	9c 91       	ld	r25, X
		NumArray[i] = NumArray[NumPointer - i - 1];
 616:	e1 2f       	mov	r30, r17
 618:	f0 e0       	ldi	r31, 0x00	; 0
 61a:	e2 1b       	sub	r30, r18
 61c:	f3 0b       	sbc	r31, r19
 61e:	31 97       	sbiw	r30, 0x01	; 1
 620:	21 e0       	ldi	r18, 0x01	; 1
 622:	30 e0       	ldi	r19, 0x00	; 0
 624:	2c 0f       	add	r18, r28
 626:	3d 1f       	adc	r19, r29
 628:	e2 0f       	add	r30, r18
 62a:	f3 1f       	adc	r31, r19
 62c:	20 81       	ld	r18, Z
 62e:	2c 93       	st	X, r18
		NumArray[NumPointer - i - 1] = temp;
 630:	90 83       	st	Z, r25
			number /= 10; 
		}
	}

	// reverse the array
	for (u8 i = 0; i < NumPointer / 2; i++) 
 632:	8f 5f       	subi	r24, 0xFF	; 255
 634:	91 2f       	mov	r25, r17
 636:	96 95       	lsr	r25
 638:	89 17       	cp	r24, r25
 63a:	20 f3       	brcs	.-56     	; 0x604 <LCD_voidSendNumber+0x60>
		u8 temp = NumArray[i];
		NumArray[i] = NumArray[NumPointer - i - 1];
		NumArray[NumPointer - i - 1] = temp;
	}

	NumArray[NumPointer] = '\0';
 63c:	e1 e0       	ldi	r30, 0x01	; 1
 63e:	f0 e0       	ldi	r31, 0x00	; 0
 640:	ec 0f       	add	r30, r28
 642:	fd 1f       	adc	r31, r29
 644:	e1 0f       	add	r30, r17
 646:	f1 1d       	adc	r31, r1
 648:	10 82       	st	Z, r1
	
	LCD_voidSendString(NumArray);
 64a:	ce 01       	movw	r24, r28
 64c:	01 96       	adiw	r24, 0x01	; 1
 64e:	0e 94 bf 02 	call	0x57e	; 0x57e <LCD_voidSendString>
}
 652:	2a 96       	adiw	r28, 0x0a	; 10
 654:	0f b6       	in	r0, 0x3f	; 63
 656:	f8 94       	cli
 658:	de bf       	out	0x3e, r29	; 62
 65a:	0f be       	out	0x3f, r0	; 63
 65c:	cd bf       	out	0x3d, r28	; 61
 65e:	df 91       	pop	r29
 660:	cf 91       	pop	r28
 662:	1f 91       	pop	r17
 664:	08 95       	ret

00000666 <LCD_voidGotoXY>:
void LCD_voidGotoXY(u8 copy_u8x,u8 copy_u8y){
	
	
	u8 DDRAM_address =0;
	
	DDRAM_address= copy_u8x + 0x40 * copy_u8y;
 666:	90 e4       	ldi	r25, 0x40	; 64
 668:	69 9f       	mul	r22, r25
 66a:	80 0d       	add	r24, r0
 66c:	11 24       	eor	r1, r1
	
	
	SET_BIT(DDRAM_address,7);
	
	
	LCD_voidSendCommand(DDRAM_address);
 66e:	80 68       	ori	r24, 0x80	; 128
 670:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <LCD_voidSendCommand>
 674:	08 95       	ret

00000676 <LCD_voidDrawData>:
	
	
}

void LCD_voidDrawData(u8 copy_u8pattern, u8 *P_u8data,u8 copy_u8x, u8 copy_u8y){
 676:	ef 92       	push	r14
 678:	ff 92       	push	r15
 67a:	0f 93       	push	r16
 67c:	1f 93       	push	r17
 67e:	cf 93       	push	r28
 680:	df 93       	push	r29
 682:	d8 2f       	mov	r29, r24
 684:	8b 01       	movw	r16, r22
 686:	f4 2e       	mov	r15, r20
 688:	e2 2e       	mov	r14, r18
	u8 CGRAM_address =0;
	u8 copy_u8in=0;
	
	// calc pattern address
	CGRAM_address = copy_u8pattern * 8;
 68a:	88 0f       	add	r24, r24
 68c:	88 0f       	add	r24, r24
 68e:	88 0f       	add	r24, r24
	
	// set CGRAM
	CLR_BIT(CGRAM_address,7);
 690:	8f 77       	andi	r24, 0x7F	; 127
	SET_BIT(CGRAM_address,6);
	LCD_voidSendCommand(CGRAM_address);
 692:	80 64       	ori	r24, 0x40	; 64
 694:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <LCD_voidSendCommand>
	
	// Draw data
	for(copy_u8in=0;copy_u8in<8;copy_u8in++){
 698:	c0 e0       	ldi	r28, 0x00	; 0
 69a:	07 c0       	rjmp	.+14     	; 0x6aa <LCD_voidDrawData+0x34>
		LCD_voidSendData(P_u8data[copy_u8in]);
 69c:	f8 01       	movw	r30, r16
 69e:	ec 0f       	add	r30, r28
 6a0:	f1 1d       	adc	r31, r1
 6a2:	80 81       	ld	r24, Z
 6a4:	0e 94 a5 02 	call	0x54a	; 0x54a <LCD_voidSendData>
	CLR_BIT(CGRAM_address,7);
	SET_BIT(CGRAM_address,6);
	LCD_voidSendCommand(CGRAM_address);
	
	// Draw data
	for(copy_u8in=0;copy_u8in<8;copy_u8in++){
 6a8:	cf 5f       	subi	r28, 0xFF	; 255
 6aa:	c8 30       	cpi	r28, 0x08	; 8
 6ac:	b8 f3       	brcs	.-18     	; 0x69c <LCD_voidDrawData+0x26>
		LCD_voidSendData(P_u8data[copy_u8in]);
	}
	
	// set DDRAM
	LCD_voidGotoXY(copy_u8x,copy_u8y);
 6ae:	6e 2d       	mov	r22, r14
 6b0:	8f 2d       	mov	r24, r15
 6b2:	0e 94 33 03 	call	0x666	; 0x666 <LCD_voidGotoXY>
	LCD_voidSendData(copy_u8pattern);
 6b6:	8d 2f       	mov	r24, r29
 6b8:	0e 94 a5 02 	call	0x54a	; 0x54a <LCD_voidSendData>
	
 6bc:	df 91       	pop	r29
 6be:	cf 91       	pop	r28
 6c0:	1f 91       	pop	r17
 6c2:	0f 91       	pop	r16
 6c4:	ff 90       	pop	r15
 6c6:	ef 90       	pop	r14
 6c8:	08 95       	ret

000006ca <LED_voidON>:
 */ 

#include "LED_interface.h"


void LED_voidON	   (u8 copy_u8port,u8 copy_u8pin){
 6ca:	cf 93       	push	r28
 6cc:	df 93       	push	r29
 6ce:	c8 2f       	mov	r28, r24
 6d0:	d6 2f       	mov	r29, r22
	DIO_voidSetPinDir(copy_u8port,copy_u8pin,OUTPUT);
 6d2:	41 e0       	ldi	r20, 0x01	; 1
 6d4:	0e 94 91 03 	call	0x722	; 0x722 <DIO_voidSetPinDir>
	DIO_voidSetPinVal(copy_u8port,copy_u8pin,HIGH);
 6d8:	41 e0       	ldi	r20, 0x01	; 1
 6da:	6d 2f       	mov	r22, r29
 6dc:	8c 2f       	mov	r24, r28
 6de:	0e 94 01 04 	call	0x802	; 0x802 <DIO_voidSetPinVal>
}
 6e2:	df 91       	pop	r29
 6e4:	cf 91       	pop	r28
 6e6:	08 95       	ret

000006e8 <LED_voidOFF>:
void LED_voidOFF   (u8 copy_u8port,u8 copy_u8pin){
 6e8:	cf 93       	push	r28
 6ea:	df 93       	push	r29
 6ec:	c8 2f       	mov	r28, r24
 6ee:	d6 2f       	mov	r29, r22
	DIO_voidSetPinDir(copy_u8port,copy_u8pin,OUTPUT);
 6f0:	41 e0       	ldi	r20, 0x01	; 1
 6f2:	0e 94 91 03 	call	0x722	; 0x722 <DIO_voidSetPinDir>
	DIO_voidSetPinVal(copy_u8port,copy_u8pin,LOW);
 6f6:	40 e0       	ldi	r20, 0x00	; 0
 6f8:	6d 2f       	mov	r22, r29
 6fa:	8c 2f       	mov	r24, r28
 6fc:	0e 94 01 04 	call	0x802	; 0x802 <DIO_voidSetPinVal>
}
 700:	df 91       	pop	r29
 702:	cf 91       	pop	r28
 704:	08 95       	ret

00000706 <LED_voidTOGGLE>:
void LED_voidTOGGLE(u8 copy_u8port,u8 copy_u8pin){
 706:	cf 93       	push	r28
 708:	df 93       	push	r29
 70a:	c8 2f       	mov	r28, r24
 70c:	d6 2f       	mov	r29, r22
	DIO_voidSetPinDir(copy_u8port,copy_u8pin,OUTPUT);
 70e:	41 e0       	ldi	r20, 0x01	; 1
 710:	0e 94 91 03 	call	0x722	; 0x722 <DIO_voidSetPinDir>
	DIO_voidTogglePinVal(copy_u8port,copy_u8pin);
 714:	6d 2f       	mov	r22, r29
 716:	8c 2f       	mov	r24, r28
 718:	0e 94 71 04 	call	0x8e2	; 0x8e2 <DIO_voidTogglePinVal>
}
 71c:	df 91       	pop	r29
 71e:	cf 91       	pop	r28
 720:	08 95       	ret

00000722 <DIO_voidSetPinDir>:



void DIO_voidSetPinDir(u8 copy_u8port,u8 copy_u8pin , u8 copy_u8dir){
	
	         if (copy_u8dir==OUTPUT)
 722:	41 30       	cpi	r20, 0x01	; 1
 724:	a1 f5       	brne	.+104    	; 0x78e <DIO_voidSetPinDir+0x6c>
	         {
				 switch(copy_u8port){
 726:	81 30       	cpi	r24, 0x01	; 1
 728:	89 f0       	breq	.+34     	; 0x74c <DIO_voidSetPinDir+0x2a>
 72a:	28 f0       	brcs	.+10     	; 0x736 <DIO_voidSetPinDir+0x14>
 72c:	82 30       	cpi	r24, 0x02	; 2
 72e:	c9 f0       	breq	.+50     	; 0x762 <DIO_voidSetPinDir+0x40>
 730:	83 30       	cpi	r24, 0x03	; 3
 732:	11 f1       	breq	.+68     	; 0x778 <DIO_voidSetPinDir+0x56>
 734:	08 95       	ret
					 
					 case DIO_PORTA : SET_BIT(DDRA_REG,copy_u8pin);break ;
 736:	2a b3       	in	r18, 0x1a	; 26
 738:	81 e0       	ldi	r24, 0x01	; 1
 73a:	90 e0       	ldi	r25, 0x00	; 0
 73c:	02 c0       	rjmp	.+4      	; 0x742 <DIO_voidSetPinDir+0x20>
 73e:	88 0f       	add	r24, r24
 740:	99 1f       	adc	r25, r25
 742:	6a 95       	dec	r22
 744:	e2 f7       	brpl	.-8      	; 0x73e <DIO_voidSetPinDir+0x1c>
 746:	82 2b       	or	r24, r18
 748:	8a bb       	out	0x1a, r24	; 26
 74a:	08 95       	ret
					 case DIO_PORTB : SET_BIT(DDRB_REG,copy_u8pin);break ;
 74c:	27 b3       	in	r18, 0x17	; 23
 74e:	81 e0       	ldi	r24, 0x01	; 1
 750:	90 e0       	ldi	r25, 0x00	; 0
 752:	02 c0       	rjmp	.+4      	; 0x758 <DIO_voidSetPinDir+0x36>
 754:	88 0f       	add	r24, r24
 756:	99 1f       	adc	r25, r25
 758:	6a 95       	dec	r22
 75a:	e2 f7       	brpl	.-8      	; 0x754 <DIO_voidSetPinDir+0x32>
 75c:	82 2b       	or	r24, r18
 75e:	87 bb       	out	0x17, r24	; 23
 760:	08 95       	ret
					 case DIO_PORTC : SET_BIT(DDRC_REG,copy_u8pin);break ;
 762:	24 b3       	in	r18, 0x14	; 20
 764:	81 e0       	ldi	r24, 0x01	; 1
 766:	90 e0       	ldi	r25, 0x00	; 0
 768:	02 c0       	rjmp	.+4      	; 0x76e <DIO_voidSetPinDir+0x4c>
 76a:	88 0f       	add	r24, r24
 76c:	99 1f       	adc	r25, r25
 76e:	6a 95       	dec	r22
 770:	e2 f7       	brpl	.-8      	; 0x76a <DIO_voidSetPinDir+0x48>
 772:	82 2b       	or	r24, r18
 774:	84 bb       	out	0x14, r24	; 20
 776:	08 95       	ret
					 case DIO_PORTD : SET_BIT(DDRD_REG,copy_u8pin);break ;
 778:	21 b3       	in	r18, 0x11	; 17
 77a:	81 e0       	ldi	r24, 0x01	; 1
 77c:	90 e0       	ldi	r25, 0x00	; 0
 77e:	02 c0       	rjmp	.+4      	; 0x784 <DIO_voidSetPinDir+0x62>
 780:	88 0f       	add	r24, r24
 782:	99 1f       	adc	r25, r25
 784:	6a 95       	dec	r22
 786:	e2 f7       	brpl	.-8      	; 0x780 <DIO_voidSetPinDir+0x5e>
 788:	82 2b       	or	r24, r18
 78a:	81 bb       	out	0x11, r24	; 17
 78c:	08 95       	ret
					 
					 
				 }
				 
	         }
	         else if (copy_u8dir==INPUT)
 78e:	41 11       	cpse	r20, r1
 790:	37 c0       	rjmp	.+110    	; 0x800 <__DATA_REGION_LENGTH__>
	         {
				 
				 switch(copy_u8port){
 792:	81 30       	cpi	r24, 0x01	; 1
 794:	91 f0       	breq	.+36     	; 0x7ba <DIO_voidSetPinDir+0x98>
 796:	28 f0       	brcs	.+10     	; 0x7a2 <DIO_voidSetPinDir+0x80>
 798:	82 30       	cpi	r24, 0x02	; 2
 79a:	d9 f0       	breq	.+54     	; 0x7d2 <DIO_voidSetPinDir+0xb0>
 79c:	83 30       	cpi	r24, 0x03	; 3
 79e:	29 f1       	breq	.+74     	; 0x7ea <DIO_voidSetPinDir+0xc8>
 7a0:	08 95       	ret
					 
					 case DIO_PORTA : CLR_BIT(DDRA_REG,copy_u8pin);break ;
 7a2:	2a b3       	in	r18, 0x1a	; 26
 7a4:	81 e0       	ldi	r24, 0x01	; 1
 7a6:	90 e0       	ldi	r25, 0x00	; 0
 7a8:	02 c0       	rjmp	.+4      	; 0x7ae <DIO_voidSetPinDir+0x8c>
 7aa:	88 0f       	add	r24, r24
 7ac:	99 1f       	adc	r25, r25
 7ae:	6a 95       	dec	r22
 7b0:	e2 f7       	brpl	.-8      	; 0x7aa <DIO_voidSetPinDir+0x88>
 7b2:	80 95       	com	r24
 7b4:	82 23       	and	r24, r18
 7b6:	8a bb       	out	0x1a, r24	; 26
 7b8:	08 95       	ret
					 case DIO_PORTB : CLR_BIT(DDRB_REG,copy_u8pin);break ;
 7ba:	27 b3       	in	r18, 0x17	; 23
 7bc:	81 e0       	ldi	r24, 0x01	; 1
 7be:	90 e0       	ldi	r25, 0x00	; 0
 7c0:	02 c0       	rjmp	.+4      	; 0x7c6 <DIO_voidSetPinDir+0xa4>
 7c2:	88 0f       	add	r24, r24
 7c4:	99 1f       	adc	r25, r25
 7c6:	6a 95       	dec	r22
 7c8:	e2 f7       	brpl	.-8      	; 0x7c2 <DIO_voidSetPinDir+0xa0>
 7ca:	80 95       	com	r24
 7cc:	82 23       	and	r24, r18
 7ce:	87 bb       	out	0x17, r24	; 23
 7d0:	08 95       	ret
					 case DIO_PORTC : CLR_BIT(DDRC_REG,copy_u8pin);break ;
 7d2:	24 b3       	in	r18, 0x14	; 20
 7d4:	81 e0       	ldi	r24, 0x01	; 1
 7d6:	90 e0       	ldi	r25, 0x00	; 0
 7d8:	02 c0       	rjmp	.+4      	; 0x7de <DIO_voidSetPinDir+0xbc>
 7da:	88 0f       	add	r24, r24
 7dc:	99 1f       	adc	r25, r25
 7de:	6a 95       	dec	r22
 7e0:	e2 f7       	brpl	.-8      	; 0x7da <DIO_voidSetPinDir+0xb8>
 7e2:	80 95       	com	r24
 7e4:	82 23       	and	r24, r18
 7e6:	84 bb       	out	0x14, r24	; 20
 7e8:	08 95       	ret
					 case DIO_PORTD : CLR_BIT(DDRD_REG,copy_u8pin);break ;
 7ea:	21 b3       	in	r18, 0x11	; 17
 7ec:	81 e0       	ldi	r24, 0x01	; 1
 7ee:	90 e0       	ldi	r25, 0x00	; 0
 7f0:	02 c0       	rjmp	.+4      	; 0x7f6 <DIO_voidSetPinDir+0xd4>
 7f2:	88 0f       	add	r24, r24
 7f4:	99 1f       	adc	r25, r25
 7f6:	6a 95       	dec	r22
 7f8:	e2 f7       	brpl	.-8      	; 0x7f2 <DIO_voidSetPinDir+0xd0>
 7fa:	80 95       	com	r24
 7fc:	82 23       	and	r24, r18
 7fe:	81 bb       	out	0x11, r24	; 17
 800:	08 95       	ret

00000802 <DIO_voidSetPinVal>:
	
	
}
void DIO_voidSetPinVal(u8 copy_u8port,u8 copy_u8pin , u8 copy_u8val){
	
	          if (copy_u8val==HIGH)
 802:	41 30       	cpi	r20, 0x01	; 1
 804:	a1 f5       	brne	.+104    	; 0x86e <__stack+0xf>
	          {
				  switch(copy_u8port){
 806:	81 30       	cpi	r24, 0x01	; 1
 808:	89 f0       	breq	.+34     	; 0x82c <DIO_voidSetPinVal+0x2a>
 80a:	28 f0       	brcs	.+10     	; 0x816 <DIO_voidSetPinVal+0x14>
 80c:	82 30       	cpi	r24, 0x02	; 2
 80e:	c9 f0       	breq	.+50     	; 0x842 <DIO_voidSetPinVal+0x40>
 810:	83 30       	cpi	r24, 0x03	; 3
 812:	11 f1       	breq	.+68     	; 0x858 <DIO_voidSetPinVal+0x56>
 814:	08 95       	ret
					  
					  case DIO_PORTA: SET_BIT(PORTA_REG,copy_u8pin);break ;
 816:	2b b3       	in	r18, 0x1b	; 27
 818:	81 e0       	ldi	r24, 0x01	; 1
 81a:	90 e0       	ldi	r25, 0x00	; 0
 81c:	02 c0       	rjmp	.+4      	; 0x822 <DIO_voidSetPinVal+0x20>
 81e:	88 0f       	add	r24, r24
 820:	99 1f       	adc	r25, r25
 822:	6a 95       	dec	r22
 824:	e2 f7       	brpl	.-8      	; 0x81e <DIO_voidSetPinVal+0x1c>
 826:	82 2b       	or	r24, r18
 828:	8b bb       	out	0x1b, r24	; 27
 82a:	08 95       	ret
					  case DIO_PORTB: SET_BIT(PORTB_REG,copy_u8pin);break ;
 82c:	28 b3       	in	r18, 0x18	; 24
 82e:	81 e0       	ldi	r24, 0x01	; 1
 830:	90 e0       	ldi	r25, 0x00	; 0
 832:	02 c0       	rjmp	.+4      	; 0x838 <DIO_voidSetPinVal+0x36>
 834:	88 0f       	add	r24, r24
 836:	99 1f       	adc	r25, r25
 838:	6a 95       	dec	r22
 83a:	e2 f7       	brpl	.-8      	; 0x834 <DIO_voidSetPinVal+0x32>
 83c:	82 2b       	or	r24, r18
 83e:	88 bb       	out	0x18, r24	; 24
 840:	08 95       	ret
					  case DIO_PORTC: SET_BIT(PORTC_REG,copy_u8pin);break ;
 842:	25 b3       	in	r18, 0x15	; 21
 844:	81 e0       	ldi	r24, 0x01	; 1
 846:	90 e0       	ldi	r25, 0x00	; 0
 848:	02 c0       	rjmp	.+4      	; 0x84e <DIO_voidSetPinVal+0x4c>
 84a:	88 0f       	add	r24, r24
 84c:	99 1f       	adc	r25, r25
 84e:	6a 95       	dec	r22
 850:	e2 f7       	brpl	.-8      	; 0x84a <DIO_voidSetPinVal+0x48>
 852:	82 2b       	or	r24, r18
 854:	85 bb       	out	0x15, r24	; 21
 856:	08 95       	ret
					  case DIO_PORTD: SET_BIT(PORTD_REG,copy_u8pin);break ;
 858:	22 b3       	in	r18, 0x12	; 18
 85a:	81 e0       	ldi	r24, 0x01	; 1
 85c:	90 e0       	ldi	r25, 0x00	; 0
 85e:	02 c0       	rjmp	.+4      	; 0x864 <__stack+0x5>
 860:	88 0f       	add	r24, r24
 862:	99 1f       	adc	r25, r25
 864:	6a 95       	dec	r22
 866:	e2 f7       	brpl	.-8      	; 0x860 <__stack+0x1>
 868:	82 2b       	or	r24, r18
 86a:	82 bb       	out	0x12, r24	; 18
 86c:	08 95       	ret
					  
					  
				  }
				  
	          }
	           else if (copy_u8val==LOW)
 86e:	41 11       	cpse	r20, r1
 870:	37 c0       	rjmp	.+110    	; 0x8e0 <__stack+0x81>
	           {
				   switch(copy_u8port){
 872:	81 30       	cpi	r24, 0x01	; 1
 874:	91 f0       	breq	.+36     	; 0x89a <__stack+0x3b>
 876:	28 f0       	brcs	.+10     	; 0x882 <__stack+0x23>
 878:	82 30       	cpi	r24, 0x02	; 2
 87a:	d9 f0       	breq	.+54     	; 0x8b2 <__stack+0x53>
 87c:	83 30       	cpi	r24, 0x03	; 3
 87e:	29 f1       	breq	.+74     	; 0x8ca <__stack+0x6b>
 880:	08 95       	ret
					   
					   case DIO_PORTA: CLR_BIT(PORTA_REG,copy_u8pin);break ;
 882:	2b b3       	in	r18, 0x1b	; 27
 884:	81 e0       	ldi	r24, 0x01	; 1
 886:	90 e0       	ldi	r25, 0x00	; 0
 888:	02 c0       	rjmp	.+4      	; 0x88e <__stack+0x2f>
 88a:	88 0f       	add	r24, r24
 88c:	99 1f       	adc	r25, r25
 88e:	6a 95       	dec	r22
 890:	e2 f7       	brpl	.-8      	; 0x88a <__stack+0x2b>
 892:	80 95       	com	r24
 894:	82 23       	and	r24, r18
 896:	8b bb       	out	0x1b, r24	; 27
 898:	08 95       	ret
					   case DIO_PORTB: CLR_BIT(PORTB_REG,copy_u8pin);break ;
 89a:	28 b3       	in	r18, 0x18	; 24
 89c:	81 e0       	ldi	r24, 0x01	; 1
 89e:	90 e0       	ldi	r25, 0x00	; 0
 8a0:	02 c0       	rjmp	.+4      	; 0x8a6 <__stack+0x47>
 8a2:	88 0f       	add	r24, r24
 8a4:	99 1f       	adc	r25, r25
 8a6:	6a 95       	dec	r22
 8a8:	e2 f7       	brpl	.-8      	; 0x8a2 <__stack+0x43>
 8aa:	80 95       	com	r24
 8ac:	82 23       	and	r24, r18
 8ae:	88 bb       	out	0x18, r24	; 24
 8b0:	08 95       	ret
					   case DIO_PORTC: CLR_BIT(PORTC_REG,copy_u8pin);break ;
 8b2:	25 b3       	in	r18, 0x15	; 21
 8b4:	81 e0       	ldi	r24, 0x01	; 1
 8b6:	90 e0       	ldi	r25, 0x00	; 0
 8b8:	02 c0       	rjmp	.+4      	; 0x8be <__stack+0x5f>
 8ba:	88 0f       	add	r24, r24
 8bc:	99 1f       	adc	r25, r25
 8be:	6a 95       	dec	r22
 8c0:	e2 f7       	brpl	.-8      	; 0x8ba <__stack+0x5b>
 8c2:	80 95       	com	r24
 8c4:	82 23       	and	r24, r18
 8c6:	85 bb       	out	0x15, r24	; 21
 8c8:	08 95       	ret
					   case DIO_PORTD: CLR_BIT(PORTD_REG,copy_u8pin);break ;
 8ca:	22 b3       	in	r18, 0x12	; 18
 8cc:	81 e0       	ldi	r24, 0x01	; 1
 8ce:	90 e0       	ldi	r25, 0x00	; 0
 8d0:	02 c0       	rjmp	.+4      	; 0x8d6 <__stack+0x77>
 8d2:	88 0f       	add	r24, r24
 8d4:	99 1f       	adc	r25, r25
 8d6:	6a 95       	dec	r22
 8d8:	e2 f7       	brpl	.-8      	; 0x8d2 <__stack+0x73>
 8da:	80 95       	com	r24
 8dc:	82 23       	and	r24, r18
 8de:	82 bb       	out	0x12, r24	; 18
 8e0:	08 95       	ret

000008e2 <DIO_voidTogglePinVal>:
	
	
}
void DIO_voidTogglePinVal(u8 copy_u8port,u8 copy_u8pin ){
	
	 switch(copy_u8port){
 8e2:	81 30       	cpi	r24, 0x01	; 1
 8e4:	89 f0       	breq	.+34     	; 0x908 <DIO_voidTogglePinVal+0x26>
 8e6:	28 f0       	brcs	.+10     	; 0x8f2 <DIO_voidTogglePinVal+0x10>
 8e8:	82 30       	cpi	r24, 0x02	; 2
 8ea:	c9 f0       	breq	.+50     	; 0x91e <DIO_voidTogglePinVal+0x3c>
 8ec:	83 30       	cpi	r24, 0x03	; 3
 8ee:	11 f1       	breq	.+68     	; 0x934 <DIO_voidTogglePinVal+0x52>
 8f0:	08 95       	ret
	case DIO_PORTA: TOGGLE_BIT(PORTA_REG,copy_u8pin);break ;
 8f2:	2b b3       	in	r18, 0x1b	; 27
 8f4:	81 e0       	ldi	r24, 0x01	; 1
 8f6:	90 e0       	ldi	r25, 0x00	; 0
 8f8:	02 c0       	rjmp	.+4      	; 0x8fe <DIO_voidTogglePinVal+0x1c>
 8fa:	88 0f       	add	r24, r24
 8fc:	99 1f       	adc	r25, r25
 8fe:	6a 95       	dec	r22
 900:	e2 f7       	brpl	.-8      	; 0x8fa <DIO_voidTogglePinVal+0x18>
 902:	82 27       	eor	r24, r18
 904:	8b bb       	out	0x1b, r24	; 27
 906:	08 95       	ret
	case DIO_PORTB: TOGGLE_BIT(PORTB_REG,copy_u8pin);break ;
 908:	28 b3       	in	r18, 0x18	; 24
 90a:	81 e0       	ldi	r24, 0x01	; 1
 90c:	90 e0       	ldi	r25, 0x00	; 0
 90e:	02 c0       	rjmp	.+4      	; 0x914 <DIO_voidTogglePinVal+0x32>
 910:	88 0f       	add	r24, r24
 912:	99 1f       	adc	r25, r25
 914:	6a 95       	dec	r22
 916:	e2 f7       	brpl	.-8      	; 0x910 <DIO_voidTogglePinVal+0x2e>
 918:	82 27       	eor	r24, r18
 91a:	88 bb       	out	0x18, r24	; 24
 91c:	08 95       	ret
	case DIO_PORTC: TOGGLE_BIT(PORTC_REG,copy_u8pin);break ;
 91e:	25 b3       	in	r18, 0x15	; 21
 920:	81 e0       	ldi	r24, 0x01	; 1
 922:	90 e0       	ldi	r25, 0x00	; 0
 924:	02 c0       	rjmp	.+4      	; 0x92a <DIO_voidTogglePinVal+0x48>
 926:	88 0f       	add	r24, r24
 928:	99 1f       	adc	r25, r25
 92a:	6a 95       	dec	r22
 92c:	e2 f7       	brpl	.-8      	; 0x926 <DIO_voidTogglePinVal+0x44>
 92e:	82 27       	eor	r24, r18
 930:	85 bb       	out	0x15, r24	; 21
 932:	08 95       	ret
	case DIO_PORTD: TOGGLE_BIT(PORTD_REG,copy_u8pin);break ;
 934:	22 b3       	in	r18, 0x12	; 18
 936:	81 e0       	ldi	r24, 0x01	; 1
 938:	90 e0       	ldi	r25, 0x00	; 0
 93a:	02 c0       	rjmp	.+4      	; 0x940 <DIO_voidTogglePinVal+0x5e>
 93c:	88 0f       	add	r24, r24
 93e:	99 1f       	adc	r25, r25
 940:	6a 95       	dec	r22
 942:	e2 f7       	brpl	.-8      	; 0x93c <DIO_voidTogglePinVal+0x5a>
 944:	82 27       	eor	r24, r18
 946:	82 bb       	out	0x12, r24	; 18
 948:	08 95       	ret

0000094a <DIO_u8ReadPinVal>:
	
}
u8 DIO_u8ReadPinVal(u8 copy_u8port,u8 copy_u8pin){
	
	 u8 LOC_u8val=0 ; 
	 switch(copy_u8port){
 94a:	81 30       	cpi	r24, 0x01	; 1
 94c:	79 f0       	breq	.+30     	; 0x96c <DIO_u8ReadPinVal+0x22>
 94e:	28 f0       	brcs	.+10     	; 0x95a <DIO_u8ReadPinVal+0x10>
 950:	82 30       	cpi	r24, 0x02	; 2
 952:	a9 f0       	breq	.+42     	; 0x97e <DIO_u8ReadPinVal+0x34>
 954:	83 30       	cpi	r24, 0x03	; 3
 956:	e1 f0       	breq	.+56     	; 0x990 <DIO_u8ReadPinVal+0x46>
 958:	24 c0       	rjmp	.+72     	; 0x9a2 <DIO_u8ReadPinVal+0x58>
		 case DIO_PORTA:LOC_u8val=GET_BIT(PINA_REG,copy_u8pin);break ;
 95a:	89 b3       	in	r24, 0x19	; 25
 95c:	90 e0       	ldi	r25, 0x00	; 0
 95e:	02 c0       	rjmp	.+4      	; 0x964 <DIO_u8ReadPinVal+0x1a>
 960:	95 95       	asr	r25
 962:	87 95       	ror	r24
 964:	6a 95       	dec	r22
 966:	e2 f7       	brpl	.-8      	; 0x960 <DIO_u8ReadPinVal+0x16>
 968:	81 70       	andi	r24, 0x01	; 1
 96a:	08 95       	ret
		 case DIO_PORTB:LOC_u8val=GET_BIT(PINB_REG,copy_u8pin);break ;
 96c:	86 b3       	in	r24, 0x16	; 22
 96e:	90 e0       	ldi	r25, 0x00	; 0
 970:	02 c0       	rjmp	.+4      	; 0x976 <DIO_u8ReadPinVal+0x2c>
 972:	95 95       	asr	r25
 974:	87 95       	ror	r24
 976:	6a 95       	dec	r22
 978:	e2 f7       	brpl	.-8      	; 0x972 <DIO_u8ReadPinVal+0x28>
 97a:	81 70       	andi	r24, 0x01	; 1
 97c:	08 95       	ret
		 case DIO_PORTC:LOC_u8val=GET_BIT(PINC_REG,copy_u8pin);break ;
 97e:	83 b3       	in	r24, 0x13	; 19
 980:	90 e0       	ldi	r25, 0x00	; 0
 982:	02 c0       	rjmp	.+4      	; 0x988 <DIO_u8ReadPinVal+0x3e>
 984:	95 95       	asr	r25
 986:	87 95       	ror	r24
 988:	6a 95       	dec	r22
 98a:	e2 f7       	brpl	.-8      	; 0x984 <DIO_u8ReadPinVal+0x3a>
 98c:	81 70       	andi	r24, 0x01	; 1
 98e:	08 95       	ret
		 case DIO_PORTD:LOC_u8val=GET_BIT(PIND_REG,copy_u8pin);break ;
 990:	80 b3       	in	r24, 0x10	; 16
 992:	90 e0       	ldi	r25, 0x00	; 0
 994:	02 c0       	rjmp	.+4      	; 0x99a <DIO_u8ReadPinVal+0x50>
 996:	95 95       	asr	r25
 998:	87 95       	ror	r24
 99a:	6a 95       	dec	r22
 99c:	e2 f7       	brpl	.-8      	; 0x996 <DIO_u8ReadPinVal+0x4c>
 99e:	81 70       	andi	r24, 0x01	; 1
 9a0:	08 95       	ret
	
	
}
u8 DIO_u8ReadPinVal(u8 copy_u8port,u8 copy_u8pin){
	
	 u8 LOC_u8val=0 ; 
 9a2:	80 e0       	ldi	r24, 0x00	; 0
		 case DIO_PORTD:LOC_u8val=GET_BIT(PIND_REG,copy_u8pin);break ;
	 }
	
	
	return LOC_u8val ; 
}
 9a4:	08 95       	ret

000009a6 <DIO_voidSetPortDir>:



void DIO_voidSetPortDir(u8 copy_u8port,u8 copy_u8dir){   //   0b00000111 ; 
	
	switch(copy_u8port){
 9a6:	81 30       	cpi	r24, 0x01	; 1
 9a8:	41 f0       	breq	.+16     	; 0x9ba <DIO_voidSetPortDir+0x14>
 9aa:	28 f0       	brcs	.+10     	; 0x9b6 <DIO_voidSetPortDir+0x10>
 9ac:	82 30       	cpi	r24, 0x02	; 2
 9ae:	39 f0       	breq	.+14     	; 0x9be <DIO_voidSetPortDir+0x18>
 9b0:	83 30       	cpi	r24, 0x03	; 3
 9b2:	39 f0       	breq	.+14     	; 0x9c2 <DIO_voidSetPortDir+0x1c>
 9b4:	08 95       	ret
		
		case DIO_PORTA : DDRA_REG=copy_u8dir;break ;
 9b6:	6a bb       	out	0x1a, r22	; 26
 9b8:	08 95       	ret
		case DIO_PORTB : DDRB_REG=copy_u8dir;break ;
 9ba:	67 bb       	out	0x17, r22	; 23
 9bc:	08 95       	ret
		case DIO_PORTC : DDRC_REG=copy_u8dir;break ;
 9be:	64 bb       	out	0x14, r22	; 20
 9c0:	08 95       	ret
		case DIO_PORTD : DDRD_REG=copy_u8dir;break ;
 9c2:	61 bb       	out	0x11, r22	; 17
 9c4:	08 95       	ret

000009c6 <__udivmodsi4>:
 9c6:	a1 e2       	ldi	r26, 0x21	; 33
 9c8:	1a 2e       	mov	r1, r26
 9ca:	aa 1b       	sub	r26, r26
 9cc:	bb 1b       	sub	r27, r27
 9ce:	fd 01       	movw	r30, r26
 9d0:	0d c0       	rjmp	.+26     	; 0x9ec <__udivmodsi4_ep>

000009d2 <__udivmodsi4_loop>:
 9d2:	aa 1f       	adc	r26, r26
 9d4:	bb 1f       	adc	r27, r27
 9d6:	ee 1f       	adc	r30, r30
 9d8:	ff 1f       	adc	r31, r31
 9da:	a2 17       	cp	r26, r18
 9dc:	b3 07       	cpc	r27, r19
 9de:	e4 07       	cpc	r30, r20
 9e0:	f5 07       	cpc	r31, r21
 9e2:	20 f0       	brcs	.+8      	; 0x9ec <__udivmodsi4_ep>
 9e4:	a2 1b       	sub	r26, r18
 9e6:	b3 0b       	sbc	r27, r19
 9e8:	e4 0b       	sbc	r30, r20
 9ea:	f5 0b       	sbc	r31, r21

000009ec <__udivmodsi4_ep>:
 9ec:	66 1f       	adc	r22, r22
 9ee:	77 1f       	adc	r23, r23
 9f0:	88 1f       	adc	r24, r24
 9f2:	99 1f       	adc	r25, r25
 9f4:	1a 94       	dec	r1
 9f6:	69 f7       	brne	.-38     	; 0x9d2 <__udivmodsi4_loop>
 9f8:	60 95       	com	r22
 9fa:	70 95       	com	r23
 9fc:	80 95       	com	r24
 9fe:	90 95       	com	r25
 a00:	9b 01       	movw	r18, r22
 a02:	ac 01       	movw	r20, r24
 a04:	bd 01       	movw	r22, r26
 a06:	cf 01       	movw	r24, r30
 a08:	08 95       	ret

00000a0a <_exit>:
 a0a:	f8 94       	cli

00000a0c <__stop_program>:
 a0c:	ff cf       	rjmp	.-2      	; 0xa0c <__stop_program>
